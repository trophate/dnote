# ACID

A（Atomicity）：原子性，事务中的操作要么全部成功要么全部失败。

C（Consistency）：一致性，数据库在事务执行前后保持一致状态。

I（Isolation）：隔离性，事务执行过程不会对其他事务产生影响，即事务不会访问到其他事务的过程状态。

D（Durability）：持久性，执行事务的结果持久化。





# 并发问题

## 脏读

事务读取到了其他事务未提交的数据。

![](../../img/InnoDB-脏读.svg)



## 不可重复读

事务中同一查询的多次查询结果不同。

![](../../img/InnoDB-不可重复读.svg)



## 幻读

事务中同一查询的多次查询结果集数量不同。

![](../../img/InnoDB-幻读.svg)



## 隔离级别

读未提交、读已提交、可重复读（默认）、串行化

隔离级别以不同的锁策略实现。

### 可重复读（RR）

事务内的一致性读将读取第一次读时所建立的快照。

对于锁定读（带有FOR UPDATE、FOR SHARE的查询）、UPDATE、DELETE，InnoDB加锁的方式取决于查询条件所使用的字段：

使用单字段的唯一索引：仅锁定匹配记录而不锁定间隙。

其他条件：锁定被扫描的整个范围，使用间隙锁或下个键锁防止其他事务对范围内的数据进行操作。

<font color=red>*</font> 此处是对执行涉及的索引加锁的说明，如果存在锁操作，InnoDB始终会在主键索引上对操作行加锁。

### 读已提交（RC）

事务内的一致性读会生成和读取自己的快照。

对于锁定读、UPDATE、DELETE，InnoDB仅锁定记录而不锁定间隙，即允许其他事务在锁定记录旁插入。间隙锁仅用作外键约束、重复键检查。

因为间隙锁被禁用，因此可能出现幻读。

额外效果：

对于UPDATE、DELETE，InnoDB会释放不匹配记录的锁，仅保留实际操作记录的锁。这大大降低了死锁的可能性，但仍可能发生。

对于UPDATE，如果目标记录已经被锁定，InnoDB会执行“半一致”读，读取最新提交版本，并以此判该记录是否匹配，如果匹配，则再次读取该记录，此时InnoDB要么锁定它要么等待锁定它。

### 读未提交（RU）

SELECT以非锁定方式执行。

### 串行化（S）

串行化跟可重复读类似，但如果禁用了自动提交，InnoDB会将所有SELECT转换为SELECT FOR SHARE。如果启用了自动提交，SELECT本身就是一个事务。因此，SELECT是只读的，并且如果要以一致（无锁）读执行，则可以串行化而不需要阻塞其他事务。（要在其他事务更新了所选行的情况下强制阻塞普通SELECT，需禁用自动提交。）

### 一致性（非锁定）读

它是一种读操作。它将某个时间点的快照作为查询结果返回，因此，它不会受到并行事务对数据更新的影响。例外的是它可以读同一事务中的更新。<font color=red>这可能会产生一个异常，SELECT能读到更新行的最新版本，也能读到其他行的旧版本，如果此时其他事务也在更新该表，SELECT可能读到该表从未存在的状态。</font>

隔离级别为可重复读时，快照将基于第一次查询时间生成，后续一致性读都会读该快照，隔离级别为读提交时，每次一致性读都会重新生成快照。

它不会对访问的表设置任何的锁。

这即是所谓的多版本并发控制（MVCC）。



## 幻影行和下一个键锁

InnoDB使用下一个键锁来防止产生幻影行。它将行级锁和间隙锁结合。InnoDB执行行级锁的方式是：当它扫描索引时，它将对访问过的记录设置共享或排他锁。因此，行级锁实际上是索引记录锁。下一个键锁还会影响索引记录之前的间隙，即下一个键锁是记录锁加上锁定记录之前间隙的间隙锁。



## 锁定读

SELECT FOR SHARE：在读到的行上设置共享锁。其他事务可以读但不能修改。如果行正被其它事务更改且没提交，则查询等待该事务提交后读最新值。

SELECT FOR UPDATE：对读到的行以UPDATE的规则加锁。

NOWAIT、SKIP LOCKED可以与FOR UPDATE、FOR UPDATE一起使用。

```sql
SELECT ... FOR UPDATE NOWAIT/SKIP LOCKED;
```

使用NOWAIT的锁定读从不等待获取行级锁，查询立即执行，如果查询的行被锁，失败并返回错误。

使用SKIP LOCKED的锁定读从不等待获取行级锁，查询立即执行，并从结果集中移除被锁定的行。

NOWAIT、SKIP LOCKED仅适用行级锁。





# 锁

## 共享锁和独占锁（行级锁）

共享锁（shared lock/S）：允许持有锁的事务读行。

排他锁（exclusive lock/X）：允许持有锁的事务修改或删除行。

如果事务A持有m行的共享锁，事务B对m行的共享锁请求将被允许，排他锁请求将被阻塞。如果事务B持有m行的排他锁，事务B对m行的所有类型锁请求将被阻塞。



## 意向锁（表级锁）

意向共享锁（intention shared lock/IS）：表示事务意图在表中各行上设置共享锁。

意向排他锁（intention exclusive lock/IX）：表示事务意图在表中各行上设置排他锁。

意向锁的协议如下：

1\. 在事务可以获取表中某行的共享锁之前，它必须先获取表上的意向共享锁或更强的意向共享锁。

2\.在事务可以获取表中某行的排他锁之前，它必须先获取表上的意向排他锁。

锁冲突：

![](../../img/InnoDB-锁冲突.svg)

如果请求锁与当前锁兼容，事务正常执行，如果请求锁与当前锁冲突，事务阻塞直到当前锁释放。如果请求锁与当前锁冲突，并且因为会导致死锁而不被允许，则会发生错误。

意向锁不会阻塞除全表请求以外的任何内容。意向锁主要目的是表示表中的某行被锁定或将要被锁定。



## 记录锁（Record Locks）

记录锁是锁索引记录的锁。记录锁始终锁定索引记录，即使没有显式的对表设置索引（InnoDB会创建一个隐藏的聚合索引）。



## 间隙锁（Gap Locks）

间隙锁是锁定索引记录之间间隙的锁。它能锁定第一条记录之前的、最后一条记录之后的整个区间。

间隙可以跨越单个索引值、多个索引值，甚至是空的。



## 下一个键锁（Next-Key Locks）

下一个键锁是索引记录上的记录锁和间隙锁的组合。



## 插入意向锁（Insert Intention Locks）

插入意向锁是在行插入之前由INSERT操作设置的一种间隙锁。多个事务在同一间隙不同位置插入记录不会阻塞。如：在区间(3, 9)中插入4（事务A）、7（事务B），不会发生阻塞。



## AUTO-INC锁

AUTO-INC锁是一种特殊的表级锁，由插入带有自增字段的行的事务获取。
