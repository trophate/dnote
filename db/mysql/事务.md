# ACID

A（Atomicity、原子性）：事务中的操作要么全部成功要么全部失败。

C（Consistency、一致性）：数据状态在事务执行前后保持一致。

I（Isolation、隔离性）：事务执行过程不会对其他事务产生影响，即事务不会访问到其他事务的过程状态。

D（Durability、持久性）：事务执行结果持久化。





# 并发问题



## 脏读

事务读取到了其他事务未提交的数据。

![](../../img/mysql-脏读.svg)



## 不可重复读

事务中同一查询的多次查询结果（值）不同。

![](../../img/mysql-不可重复读.svg)



## 幻读

事务中同一查询的多次查询结果集数量不同。

![](../../img/mysql-幻读.svg)



## 隔离级别

读未提交、读已提交、可重复读、串行化

隔离级别以不同的锁策略实现。

### 可重复读

RR

RR是默认隔离级别。

事务内的一致性读将读取第一次读时所建立的快照。

对于锁定读、UPDATE、DELETE，InnoDB会在主键索引上对操作行加行锁，对查询使用的索引加锁。

对索引加锁的方式取决于索引本身：

- 由单个字段组成的唯一索引：仅锁定行而不锁定间隙。
- 其他：锁定整个检索范围，使用间隙锁或下个键锁防止其他事务向该范围内插入新行。



### 读已提交

RC

事务内的一致性读会生成和读取自己的快照。

对于锁定读、UPDATE、DELETE，InnoDB仅锁定行而不锁定间隙，即允许其他事务在锁定行旁插入新行。间隙锁仅用作外键约束、重复键检查。

因为间隙锁被禁用，因此可能出现幻读。

额外效果：

- 对于UPDATE、DELETE，InnoDB仅锁定匹配的行。在MySQL评估WHERE条件后，不匹配行的锁将被释放。这大大降低了死锁的可能性，但仍可能发生。
- 对于UPDATE，如果目标行已经被锁定，InnoDB执行“半一致”读，将最新提交的版本返回给MySQL。MySQL以此判断该行是否匹配，如果匹配，则再次读取该行，此时InnoDB要么锁定它，要么等待锁定它。

### 读未提交

RU

SELECT以非锁定方式执行。

### 串行化

S

串行化跟可重复读类似，但如果禁用了自动提交，InnoDB会将所有SELECT转换为SELECT FOR SHARE。如果启用了自动提交，SELECT本身就是一个事务。因此，SELECT是只读的，并且如果要以一致（无锁）读执行，则可以串行化而不需要阻塞其他事务。（要在其他事务更新了所选行的情况下强制阻塞普通SELECT，需禁用自动提交。）



## 一致性（非锁定）读

它是一种读操作。它将某个时间点的快照作为查询结果返回，因此，它不会受到并行事务对数据更新的影响。例外的是它可以读同一事务中的更新。<font color=red>这可能会产生一个异常，SELECT能读到更新行的最新版本，也能读到其他行的旧版本，如果此时其他事务也在更新该表，SELECT可能读到该表从未存在的状态。</font>

隔离级别为可重复读时，快照将基于第一次查询时间生成，后续一致性读都会读该快照，隔离级别为读提交时，每次一致性读都会重新生成快照。

它不会对访问的表加任何锁。

这即是多版本并发控制（MVCC）。



## 幻影行和下一个键锁

InnoDB使用下一个键锁来防止产生幻影行。它将行锁和间隙锁结合。InnoDB加行锁的过程是：当它扫描索引时，它将对访问过的行设置共享或排他锁。因此，行锁实际上是索引行锁。下一个键锁还会影响索引行之前的间隙，即下一个键锁是行锁加上锁定行之前间隙的间隙锁。



## 锁定读

SELECT FOR SHARE：在读到的行上设置共享锁。其他事务可以读但不能修改。如果行正被其它事务更改且没提交，则查询等待该事务提交后读最新值。

SELECT FOR UPDATE：对读到的行以UPDATE的规则加锁。

NOWAIT、SKIP LOCKED可以与FOR UPDATE、FOR UPDATE一起使用。

```sql
SELECT ... FOR UPDATE NOWAIT/SKIP LOCKED;
```

- 使用NOWAIT的锁定读从不等待获取行级锁，查询立即执行，如果查询的行被锁，失败并返回错误。
- 使用SKIP LOCKED的锁定读从不等待获取行级锁，查询立即执行，并从结果集中移除被锁定的行。
- NOWAIT、SKIP LOCKED仅适用行级锁。





# 锁

## 共享锁和排他锁

共享锁和排他锁是行级锁。

共享锁（shared lock、S）：允许持有锁的事务读行。

排他锁（exclusive lock、X）：允许持有锁的事务修改或删除行。

如果事务A持有m行的S锁，事务B对m行的S锁请求将被允许，X锁请求将被阻塞。如果事务B持有m行的X锁，事务B对m行的所有类型锁请求将被阻塞。



## 意向锁

意向锁是表级锁。

意向共享锁（intention shared lock、IS）：表示事务意图在表中各行上设置共享锁。

意向排他锁（intention exclusive lock、IX）：表示事务意图在表中各行上设置排他锁。

意向锁的协议如下：

1. 在事务可以获取表中某行的S锁之前，它必须先获取表上的IS锁或更强的IS锁。
2. 在事务可以获取表中某行的X锁之前，它必须先获取表上的IX锁。

锁冲突：

![](../../img/mysql-锁冲突.svg)

如果请求锁与当前锁兼容，事务正常执行，如果请求锁与当前锁冲突，事务阻塞直到当前锁释放。如果请求锁与当前锁冲突，并且因为会导致死锁而不被允许，则会发生错误。

意向锁不会阻塞除全表请求以外的任何内容。意向锁主要目的是表示表中的某行被锁定或将要被锁定。



## 记录锁

Record Locks

记录锁是锁索引记录的锁。记录锁始终锁定索引记录，即使没有显式的对表设置索引（InnoDB会创建一个隐藏的聚合索引）。



## 间隙锁（Gap Locks）

间隙锁是锁定索引记录之间间隙的锁。它能锁定第一条记录之前的、最后一条记录之后的整个区间。

间隙可以跨越单个索引值、多个索引值，甚至是空的。



## 下一个键锁（Next-Key Locks）

下一个键锁是索引记录上的记录锁和间隙锁的组合。



## 插入意向锁（Insert Intention Locks）

插入意向锁是在行插入之前由INSERT操作设置的一种间隙锁。多个事务在同一间隙不同位置插入记录不会阻塞。如：在区间(3, 9)中插入4（事务A）、7（事务B），不会发生阻塞。



## AUTO-INC锁

AUTO-INC锁是一种特殊的表级锁，由插入带有自增字段的行的事务获取。





# 数据查询和操作



## 事务

```sql
SHOW ENGINE INNODB STATUS;
```

```sql
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
```



## 锁

```sql
SELECT * FROM PERFORMANCE_SCHEMA.DATA_LOCKS;
```

```sql
SELECT * FROM PERFORMANCE_SCHEMA.DATA_LOCK_WAITS;
```



## 进程

```sql
SHOW PROCESSLIST;
```



## 杀死进程

```sql
KILL ID
```

