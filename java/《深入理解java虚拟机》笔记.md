# 2章 自动内存管理



## 运行数据区域

虚拟机将管理的内存划分为多个区域，每个区域有不同的功能和生命周期。周期有的依附于虚拟机，有的依附于线程。

![](../img/运行时数据区域.png)

### 程序计数器

计数器记录线程待执行字节码的地址。字节码解释器通过程序计数器获取下一个要执行的字节码。



线程具有独立的计数器，计数器间相互独立互不影响。（这类内存被称为线程私有内存。）

原因：虚拟机线程被多个处理器（内核）交替执行。



内容：

- Java方法：字节码地址。
- Native方法：空（Undefined）。



计数器是唯一在《规范》（《Java虚拟机规范》）中没有被规定任何内存溢出情况的区域。

### Java虚拟机栈

虚拟机栈是线程私有的。



栈帧是方法运行内存。栈帧在方法被调用时被创建、入栈，方法结束时被出栈、销毁。



内容：局部变量表、操作数栈、动态链接、方法出入口信息等。



《规范》对其内存异常规定：

- 访问超过栈最大深度时，JVM抛出栈溢出。
- 扩容时无法申请到空间时，JVM抛出内存溢出。

#### 局部变量表

内容：基本数据类型、引用、returnAddress。



存储空间用变量槽表示（slot），long、double占两个槽，其他类型占一个槽。



表所需空间大小在编译期确定，在栈帧创建和方法执行期间不会改变。（大小指槽数，槽的大小（如32bit、64bit）由具体的虚拟机实现确定。）

### 本地方法栈

本地方法栈作用类似于Java虚拟机栈，作用对象是本地方法。

### Java堆

堆被所有线程共享内存。



堆在虚拟机启动时创建。



内容：对象实例。



堆是被垃圾收集器管理的区域。



《规范》没有对其进行进一步的划分，细分是为了满足特定垃圾收集器的实现。



堆可以被实现为固定或可扩展（主流实现）的。可扩展堆使用-Xmx、-Xms设置大小。



《规范》对其内存异常规定：

- 无可用空间且无法扩展时，JVM抛出内存溢出。


### 方法区

方法区是线程共享内存。



内容：类型信息、常量、静态变量、即时编译器编译后的代码缓存等。



永久代≠方法区

永久代是垃圾收集器中的概念，早期hotSpot将垃圾收集器分区拓展到方法区，将方法区作为永久代实现。现在hotSpot已经废弃永久代的概念，采用本地内存来实现方法区。



《规范》对其内存异常规定：

- 无可用内存时，JVM抛出内存溢出。

#### 运行时常量池

运行时常量池是方法区的一部分。Class文件中有项信息是常量池表，该表用于存储编译期生成的各种字面量与符号引用，这部分数据在类加载后存放到运行时常量池。

### 直接内存



# 3章 垃圾收集器与内存分配策略



## 对象已死

### 引用计数法

方法为对象分配一个计数器，对象被引用计数器 + 1，对象引用失效计数器 - 1。

问题：如果存在两个相互引用的对象，对象就不能被回收。

### 可达性分析法

以一系列被称为GC Roots的对象为起点，如果某对象不能以GC Roots为起点被访问到，那么该对象的引用即为失效。访问的路径被称为引用链。

GC Roots对象：

### 引用

强引用、软引用、弱引用、虚引用

强引用：Object obj = new Object()，只要强引用还存在，对象就不会被回收。

软引用：对象在内存溢出前回收。

弱引用：对象只能存活至下一次垃圾收集。

虚引用：虚引用无法获取对象，它的唯一作用是对象被回收时收到一个系统通知。

### 生存还是死亡

如果对象在进行可行性分析后发现没有引用链，该对象被第一次标记。随后进行一次筛选，判断对象是否需要执行finalize()。如果finalize()被对象重写或JVM已经调用过finalize()，那么JVM判断该对象不需要执行finalize()。

如果对象需要执行finalize()，那么它将会被放入F-Queue队列，并在稍后由JVM自动创建的、低调度优先级的Finalizer线程去执行它的finalize()。Finalizer线程只是触发执行，不会等待其执行完成。

收集器会对F-Queue队列中的对象进行第二次标记，如果对象在finalize()中重新构建了引用链，则对象会被移除待回收集合。

总结：两次标记确定对象死亡。



## 垃圾收集算法

### 分代收集算法

算法将收集区域分代，分为新生代、老年代。新生代中的对象大都存活期短，老年代中的对象存活期长，新生代中存活较长的对象将逐步移至老年代。

划分区域后垃圾收集器每次就对单一区域进行收集，因此垃圾收集器也有了不同回收类型划分。



划分了区域后，不同区域的对象存在互相引用（跨代引用）的情况。为了避免全局扫描老年代，只需在新生代创建一个全局的数据结构——记忆集（remember set）。记忆集将老年代划分成众多小块，并记录哪些块存在跨代引用。在Minor GC时，老年代在跨代引用的小块内存中的对象才会用可达性分析进行扫描。

### 标记——清除算法

算法标记将要被清除的对象，然后清除标记对象，或者标记存活的对象，然后清除未标记对象。

缺点：效率不稳定、空间碎片化。

### 标记——复制算法

算法将区域分为容量相同的两块，每次只使用其中的一块，当这块内存满了，就将存活的对象复制到另一块，然后清空这块内存。

缺点：空间浪费。

### 标记——整理算法

算法标记过程与标记-清除一样。清除时，算法让所有存活对象向左移动，然后直接清除边界以外的区域。



## 垃圾收集器

### Serial

Serial是新生代单线程收集器，采用标记——复制算法，在收集时会暂停其他线程直到结束。

### ParNew

ParNew是Serial的多线程版本。

### Parallel Scavenge

Parallel Scavenge是关注吞吐量的新生代多线程收集器，采用标记——复制算法。

它通过两个参数控制吞吐量：

1. -XX： MaxGCPauseMillis：单次最大收集时间。
2. -XX： GCTimeRatio：收集时间与代码运行时间的比值。

### Serial Old

Serial Old是Serial的老年代版本，采用标记——整理算法。

### Parallel Old

Parallel Old是Parallel Scavenge的老年代版本，采用标记——整理算法。

### CMS

CMS是一种以获取最短回收停顿时间为目标的老年代收集器，采用标记——清除算法。

步骤：

1. 初始标记：该操作标记与GC Roots直接关联的对象，速度很快，会暂停用户线程。
2. 并发标记：该操作标记GC Roots所有可达对象，速度很慢，不会暂停用户线程。
3. 重新标记：该操作修正并发标记时被用户线程变更的对象标记，速度很快，会暂停用户线程。
4. 并发清除：该操作清除已死对象，速度很慢，不会暂停用户线程。

### G1



### Shenandoah  



### ZGC



# 6章 类文件结构  



# 7章  类加载机制

类的加载、连接、初始化是在程序运行时动态执行的。



加载过程：加载→（验证→准备→解析）→初始化→使用→卸载

​                                              连接



