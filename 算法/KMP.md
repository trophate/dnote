KMP通过匹配失败信息来减少模式串与主串的匹配次数。





# 部分匹配表

PMT

PMT是记录以首字符开头的字串的最长相同前后缀长度的表。

PMT是KMP的核心。



前缀：首字符开头且不包含末尾字符的子串。

后缀：末尾字符结尾且不包含首字符的子串。

例：accab

前缀集合：{a, ac, acc, acca}

后缀集合：{b, ab, cab, ccab}





# 流程

主串：eopabcabem、模式串：abcabu

模式串的PMT：

![](../img/KMP流程-前缀表.svg)

匹配过程：

![](../img/KMP流程.svg)

匹配失败后不移动主串指针，通过PMT来移动模式串指针，然后继续匹配。





# 构建PMT（next数组）

（同缀：同前后缀、长同缀：最长相同前后缀）

S：aabaaa、长度：len

假设已执行到对子串aabaaa（[0, len - 1]，A）求解，此时已求解数据如下：

![](../img/构建PMT-PMT.svg)

对于A，如果存在长度为m的同缀，则有字串aabaa（[0, len - 2]，B）中存在长度为m - 1的同缀且B[m] == A[len - 1]（B[m]即为前缀后的第一个字符。）。

![](../img/构建PMT-求解方法.svg)

例：

![](../img/构建PMT-求解方法-例.svg)

因此问题可以转化为在B中找长度为m - 1且满足B[m] == A[len - 1]的同缀，且m要尽可能的大。

B的长同缀已求得，所以有：

![](../img/构建PMT-求m-1.svg)

但此时B[m]（b） != A[len - 1]（a）。此时m是最大了，于是考虑是否存在小一点的m满足条件。

此时前缀为aa（[0, m - 1]，C），后缀为aa（[len - 1 + m,  len - 2]，D），将C、D分别截取一部分使得剩余部分相等，即可获得更小的m。

例：

![](../img/构建PMT-截取前后缀-例.svg)

又因为C == D，所以剩余部分是C（D）的同缀。因此问题转化为求C的长同缀。（缩小m即求当前同缀的长同缀。）

![](../img/构建PMT-求m-2.svg)

此时B[m]（a） == A[len - 1]（a），所以求得$m_{max}$ = 2。 

如果直到cLen == 0都不存在B[m] == A[last]，那么当前串就没有长同缀。

对于其他字串的求解同理，对于len == 1的字串，设定默认值0。



## 流程总结

1. next[0] = 0;
2. 对于结束索引为i的子串A（[0, i - 1]），递归求解B串（[0, i - 2]）的最长相同前后缀长度m。如果存在B[m] == A[last]，则当前m为解，如果不存在，则解为0。



## next数组

next数组将PTM结果整体向右移动并将首位设置为-1。